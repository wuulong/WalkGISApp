
export const resolveMapImagePath = (baseUrl: string, path: string | undefined): string | null => {
  if (!path) return null;
  if (path.startsWith('http')) return path;
  
  const filename = path.split(/[/\\]/).filter(Boolean).pop();
  if (!filename) return null;
  
  return `${baseUrl}assets/images/${filename}`;
};

export const getContentBaseUrl = (baseUrl: string) => `${baseUrl}features/`;
export const getMapsBaseUrl = (baseUrl: string) => `${baseUrl}maps/`;

const stripFrontmatter = (md: string): string => md.replace(/^---\s*[\s\S]*?---\s*/, '');

const fetchMarkdown = async (baseUrl: string, id: string, folderName: string): Promise<string> => {
  // 1. 處理 ID，如果 ID 已經帶有 .md，則不重複添加
  const cleanId = id.toLowerCase().endsWith('.md') ? id.slice(0, -3) : id;
  
  // 2. 準備嘗試的路徑 (小寫與大寫)
  const urls = [
    `${baseUrl}${cleanId}.md`,
    `${baseUrl}${cleanId}.MD`
  ];

  let lastError = "";

  for (const url of urls) {
    const encodedUrl = encodeURI(url);
    try {
      console.log(`[ContentService] Attempting to fetch ${folderName}: ${encodedUrl}`);
      const response = await fetch(encodedUrl);
      
      if (response.ok) {
        const rawText = await response.text();
        console.log(`[ContentService] Successfully loaded from: ${encodedUrl}`);
        return stripFrontmatter(rawText);
      } else {
        lastError = `Status: ${response.status} ${response.statusText}`;
        console.warn(`[ContentService] Failed on ${encodedUrl}: ${lastError}`);
      }
    } catch (error: any) {
      lastError = error.message;
      console.error(`[ContentService] Network error on ${encodedUrl}:`, error);
    }
  }
  
  // 如果所有嘗試都失敗，回傳一個包含偵錯資訊的特殊字串 (用於 UI 顯示)
  return `<!-- FETCH_ERROR --> 抱歉，找不到該說明的 Markdown 檔案。\n\n**嘗試路徑：**\n- ${urls[0]}\n- ${urls[1]}\n\n請確認檔案已上傳至 GitHub 且路徑正確。`;
};

export const fetchFeatureMarkdown = async (baseUrl: string, featureId: string): Promise<string> => {
  return fetchMarkdown(getContentBaseUrl(baseUrl), featureId, 'features');
};

export const fetchMapMarkdown = async (baseUrl: string, mapId: string): Promise<string> => {
  const content = await fetchMarkdown(getMapsBaseUrl(baseUrl), mapId, 'maps');
  if (!content || content.startsWith('<!-- FETCH_ERROR -->')) return "";
  return content.replace(/^##\s+.*(?:清單|列表|Features|POI)[\s\S]*$/mi, '').trim();
};

export const generateNotebookContext = (map: any, features: any[]) => {
  let context = `# 地圖脈絡：${map.name}\n\n`;
  context += `描述：${map.description || '無描述'}\n\n`;
  context += `## 景點清單 (${features.length} 個點位)\n\n`;
  
  features.forEach((f, i) => {
    context += `### ${i + 1}. ${f.name}\n`;
    context += `- ID: ${f.feature_id}\n`;
    context += `- 座標: ${f.geometry_wkt}\n`;
    if (f.description) context += `- 簡介: ${f.description}\n`;
    context += `\n`;
  });
  
  context += `\n--- \nGenerated by WalkGIS Protocol v2.0 Context Engine`;
  return context;
};

export const generateKml = (features: any[]) => {
  let kml = `<?xml version="1.0" encoding="UTF-8"?><kml xmlns="http://www.opengis.net/kml/2.2"><Document><name>WalkGIS Export</name>`;
  features.forEach(f => {
    const match = f.geometry_wkt.match(/POINT\s*\(\s*([-\d.]+)\s+([-\d.]+)\s*\)/i);
    if (match) {
      kml += `<Placemark><name>${f.name}</name><Point><coordinates>${match[1]},${match[2]},0</coordinates></Point></Placemark>`;
    }
  });
  return kml + `</Document></kml>`;
};

export const downloadFile = (content: string, filename: string, mimeType: string) => {
  const blob = new Blob([content], { type: mimeType });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
